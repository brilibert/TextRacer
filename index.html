<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Text Racer</title>
  <style>
    :root{
      --bg:#0e0f12;
      --panel:#14161b;
      --panel2:#0f1116;
      --ink:#e9eef7;
      --muted:#a8b0c0;
      --line:#2a2f3a;
      --btn:#1e2330;
      --btn2:#2a3142;
      --shadow: rgba(0,0,0,.35);
      --r:16px;
      --a:#52ffa8;
      --b:#ff5c7a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1000px 600px at 30% 10%, #1a1e27 0%, var(--bg) 55%) fixed;
      color:var(--ink);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex;
      justify-content:center;
      padding:18px;
    }
    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
    }
    @media (max-width: 900px){ .wrap{grid-template-columns:1fr} }
    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: 0 10px 30px var(--shadow);
      overflow:hidden;
    }
    .canvasWrap{padding:12px}
    canvas{
      width:100%;
      height:520px;
      display:block;
      border-radius:12px;
      background: #0b0c10;
      border:1px solid #232938;
    }
    .side{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding-bottom:10px;
      border-bottom:1px solid var(--line);
      margin-bottom:4px;
    }
    .title h1{
      font-size:14px;
      letter-spacing:.08em;
      margin:0;
      color:#dce6ff;
      text-transform:uppercase;
    }
    .sub{ color:var(--muted); font-size:12px; margin-top:4px; }
    .tag{ font-size:12px; color:var(--muted); }
    .row{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(255,255,255,.03);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      color:#dfe7ff;
      font-size:12px;
      min-width: 92px;
      justify-content:center;
    }
    .fuel{
      height:12px;
      background:#0b0c10;
      border:1px solid #232938;
      border-radius:999px;
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .fuel > div{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(82,255,168,.9), rgba(82,255,168,.45));
      border-right:1px solid rgba(255,255,255,.15);
      transition: width .25s ease;
    }
    .controls{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .btn{
      user-select:none;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border-radius:18px;
      padding:14px 12px;
      font-weight:800;
      letter-spacing:.06em;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height:54px;
      text-transform:uppercase;
    }
    .btn:active{transform: translateY(1px)}
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .btn.roll{ grid-column: 1 / -1; font-size:15px; }
    .hint{
      color:var(--muted);
      font-size:12px;
      padding:10px 12px;
      border:1px dashed rgba(255,255,255,.12);
      border-radius:14px;
      background: rgba(255,255,255,.02);
    }
    .log{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      min-height:160px;
      max-height:210px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      color:#d6ddf2;
      white-space:pre-wrap;
    }
    .miniBtns{ display:flex; gap:10px; }
    .mini{
      cursor:pointer;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--ink);
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
      flex:1;
    }
    .mini:active{transform: translateY(1px)}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      border:1px solid rgba(255,255,255,.18);
      padding:1px 6px;
      border-radius:8px;
      color:#dce6ff;
      background: rgba(255,255,255,.06);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card side">
      <div class="title">
        <div>
          <h1>Text Racer</h1>
          <div class="sub">Getaway race. Within 3 (behind): PASS challenge.</div>
        </div>
        <div class="tag" id="seedTag"></div>
      </div>

      <div class="row">
        <div style="flex:1">
          <div class="tag">Fuel (turns left)</div>
          <div style="margin-top:6px" class="fuel"><div id="fuelBar"></div></div>
        </div>
        <div class="pill"><span>â›½</span><strong id="fuelNum">0</strong></div>
      </div>

      <div class="row">
        <div class="tag">Rolls</div>
        <div style="display:flex;gap:10px">
          <div class="pill" style="border-color: rgba(82,255,168,.35)">A: <strong id="rA">â€“</strong></div>
          <div class="pill" style="border-color: rgba(255,92,122,.35)">B: <strong id="rB">â€“</strong></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn roll" id="btnRoll">ðŸŽ² ROLL</button>
        <button class="btn" id="btnAccel" disabled>â¬†ï¸Ž ACCELERATE</button>
        <button class="btn" id="btnPass" disabled>â†”ï¸Ž PASS</button>
      </div>

      <div class="hint" id="hintText"></div>

      <div class="miniBtns">
        <button class="mini" id="btnNew">NEW RACE</button>
        <button class="mini" id="btnSpeed">SPEED: NORMAL</button>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (rng, a, b) => Math.floor(rng() * (b - a + 1)) + a;

  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }

  // ---------- config ----------
  const TRACK_LEN = 60;        // indices: 0..TRACK_LEN
  const PASS_RANGE = 3;        // within 3 spaces (and behind) to enable PASS
  const PASS_FAIL_FWD = 2;     // if PASS fails, A moves +2
  const FUEL_MIN = 20;
  const FUEL_MAX = 25;

  const GRID_W = 24, GRID_H = 14; // for path generation (visual only)

  const COLORS = {
    A: getComputedStyle(document.documentElement).getPropertyValue('--a').trim(),
    B: getComputedStyle(document.documentElement).getPropertyValue('--b').trim(),
    rail: "#2a3142",
    glow: "rgba(82,255,168,.08)"
  };

  let speedMode = "normal"; // normal | fast
  // "old game vibe": slightly slower visuals (no gameplay impact)
  const animMs = () => speedMode === "fast" ? 160 : 300;

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const seedTag = document.getElementById('seedTag');
  const elFuelNum = document.getElementById('fuelNum');
  const elFuelBar = document.getElementById('fuelBar');
  const elRA = document.getElementById('rA');
  const elRB = document.getElementById('rB');
  const elLog = document.getElementById('log');
  const hintText = document.getElementById('hintText');

  const btnRoll = document.getElementById('btnRoll');
  const btnAccel = document.getElementById('btnAccel');
  const btnPass  = document.getElementById('btnPass');
  const btnNew   = document.getElementById('btnNew');
  const btnSpeed = document.getElementById('btnSpeed');

  function log(line){
    elLog.textContent = (line + "\n" + elLog.textContent).slice(0, 4200);
  }
  function logTurn(line1, line2){
    log(line1);
    if(line2) log(line2);
  }

  // ---------- game state ----------
  let rng, seed;

  // Visual track points (kept for the canvas vibe)
  let track = []; // [{x,y}] length TRACK_LEN+1

  // Positions (single dimension)
  let posA = 0, posB = 0;

  // Fuel
  let fuel = 0;
  let fuelStart = 0;

  // Movement rolls (shown)
  let rollA = null, rollB = null;

  // Choices
  let choiceA = null; // "ACCELERATE" | "PASS"
  // B is always ACCELERATE (single-player A-seat)
  const choiceB = "ACCELERATE";

  let phase = "needRoll"; // needRoll -> needChoice -> resolving -> over

  // tie-break: who was leading at the start of the last resolved turn
  let tieBreak = "A";

  // animation floats
  const anim = {
    active:false,
    t0:0,
    ms:300,
    from:{ a:{pos:0}, b:{pos:0} },
    to:{ a:{pos:0},   b:{pos:0} },
    a:{pos:0},
    b:{pos:0},
  };

  // hud flash
  let flash = null; // {text,color,t0,ms}
  function doFlash(text, color){
    flash = {text, color, t0: performance.now(), ms: 900};
  }

  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  // ---------- track generation (visual only) ----------
  function generateTrack(){
    const used = new Set();
    const start = {x:2, y: Math.floor(GRID_H/2)};
    let p = {x:start.x, y:start.y};
    used.add(`${p.x},${p.y}`);
    const pts = [p];

    let lastDir = {dx:1, dy:0};

    for(let i=0;i<TRACK_LEN;i++){
      const candidates = [
        {dx: 1, dy: 0, w: 5},
        {dx: 0, dy:-1, w: 2},
        {dx: 0, dy: 1, w: 2},
        {dx:-1, dy: 0, w: 0.6},
      ];

      for(const c of candidates){
        if(c.dx === -lastDir.dx && c.dy === -lastDir.dy) c.w *= 0.25;
      }

      const feas = [];
      for(const c of candidates){
        const nx = p.x + c.dx, ny = p.y + c.dy;
        if(nx < 1 || nx > GRID_W-2 || ny < 1 || ny > GRID_H-2) continue;
        const key = `${nx},${ny}`;
        if(used.has(key)) continue;
        let w = c.w * (c.dx === 1 ? 1.0 + i/60 : 1.0);
        feas.push({nx, ny, dx:c.dx, dy:c.dy, w});
      }
      if(!feas.length) return null;

      let total = feas.reduce((s,f)=>s+f.w,0);
      let r = rng() * total;
      let pick = feas[0];
      for(const f of feas){
        r -= f.w;
        if(r <= 0){ pick = f; break; }
      }
      p = {x: pick.nx, y: pick.ny};
      used.add(`${p.x},${p.y}`);
      pts.push(p);
      lastDir = {dx: pick.dx, dy: pick.dy};
    }
    return pts;
  }

  function newRace(forcedSeed){
    seed = (forcedSeed ?? Math.floor(Math.random()*1e9)) >>> 0;
    rng = mulberry32(seed);

    let t = null;
    for(let k=0;k<25;k++){
      t = generateTrack();
      if(t) break;
      seed = (seed + 1337) >>> 0;
      rng = mulberry32(seed);
    }
    if(!t){
      t = Array.from({length: TRACK_LEN+1}, (_,i)=>({x:2+i, y:Math.floor(GRID_H/2)}));
    }
    track = t;

    posA = 0;
    posB = 0;

    fuelStart = randInt(rng, FUEL_MIN, FUEL_MAX);
    fuel = fuelStart;

    rollA = rollB = null;
    choiceA = null;
    phase = "needRoll";

    tieBreak = "A";

    anim.active = false;
    anim.a.pos = posA;
    anim.b.pos = posB;

    seedTag.textContent = `SEED ${seed}`;
    elLog.textContent = "";
    log("NEW RACE");
    syncUI();
    draw();
  }

  // ---------- rules ----------
  function movementRollFor(posMe, posOther){
    // Base 1d6. If behind, 25% chance of 2d6.
    const behind = posMe < posOther;
    if(behind && rng() < 0.25){
      return randInt(rng, 1, 6) + randInt(rng, 1, 6);
    }
    return randInt(rng, 1, 6);
  }

  function isPassAvailableA(){
    return (posA < posB) && ((posB - posA) <= PASS_RANGE);
  }

  function endIfOver(){
    if (fuel <= 0 || posA >= TRACK_LEN || posB >= TRACK_LEN){
      phase = "over";
      btnRoll.disabled = btnAccel.disabled = btnPass.disabled = true;

      let winner;
      if (posA === posB){
        // tie-break: whoever was leading at start of last resolved turn wins
        winner = (tieBreak === "A") ? "A WINS" : "B WINS";
      } else {
        winner = (posA > posB) ? "A WINS" : "B WINS";
      }

      log(`â€” ${winner} â€”  (A:${posA}  B:${posB})`);
      doFlash(winner, winner === "A WINS" ? COLORS.A : COLORS.B);
      syncUI();
      draw();
      return true;
    }
    return false;
  }

  function collisionFix(aPos, bPos){
    if(aPos !== bPos) return {aPos, bPos};
    // user rule: if collision would occur, A ends one square behind
    const fixedA = Math.max(0, bPos - 1);
    return {aPos: fixedA, bPos};
  }

  // PASS (A-seat):
  // - only available if A is behind and within 3
  // - hidden reroll contest (not shown)
  // - if A wins: after B accelerates, A ends at (B+1) no matter what
  // - if A loses or ties: A moves +2
  // B always accelerates
  function resolveTurn(){
    phase = "resolving";
    syncUI();
    elRB.textContent = String(rollB);

    // tie-break snapshot (leader at start of turn)
    tieBreak = (posA >= posB) ? "A" : "B";

    const passAvail = isPassAvailableA();

    // B accelerates first in our computation (but final ordering doesn't matter because A PASS success overrides AFTER)
    const bNext = clamp(posB + rollB, 0, TRACK_LEN);

    let aNext;
    let noteLine = null;

    if(choiceA === "PASS" && passAvail){
      // hidden PASS reroll (do not display)
      const passA = randInt(rng, 1, 6);
      const passB = randInt(rng, 1, 6);

      if(passA > passB){
        // PASS SUCCEEDED: A ends one ahead of B after B's accel, regardless of B roll
        aNext = bNext + 1; // can exceed TRACK_LEN -> win
        noteLine = "PASS SUCCEEDED";
        doFlash("PASS SUCCEEDED", COLORS.A);
      } else {
        // PASS FAILED (includes ties)
        aNext = posA + PASS_FAIL_FWD;
        noteLine = "PASS FAILED";
        doFlash("PASS FAILED", COLORS.B);
      }

      logTurn(
        `A:PASS       r${rollA} | B:ACCEL      r${rollB}`,
        noteLine
      );

    } else if(choiceA === "PASS" && !passAvail){
      // Should never happen (button disabled), but keep deterministic.
      aNext = posA + PASS_FAIL_FWD;
      noteLine = "PASS FAILED";
      doFlash("PASS FAILED", COLORS.B);
      logTurn(
        `A:PASS*      r${rollA} | B:ACCEL      r${rollB}`,
        "PASS FAILED"
      );

    } else {
      // A accelerates
      aNext = posA + rollA;
      logTurn(`A:ACCEL      r${rollA} | B:ACCEL      r${rollB}`);
    }

    // If A is past the end, A wins immediately (as discussed).
    if(aNext > TRACK_LEN){
      // Commit winner state; snap A to finish for display
      posA = TRACK_LEN;
      posB = bNext;

      fuel = Math.max(0, fuel - 1);

      syncUI();
      animateTo({posA, posB}, "A WINS");
      return;
    }

    // Clamp movement to track
    aNext = clamp(aNext, 0, TRACK_LEN);

    // Collision rule (can't end on same square)
    const fixed = collisionFix(aNext, bNext);
    aNext = fixed.aPos;

    // Commit
    posA = aNext;
    posB = bNext;

    // Consume fuel
    fuel = Math.max(0, fuel - 1);

    syncUI();
    animateTo({posA, posB});
  }

  // ---------- UI ----------
  function syncUI(){
    elFuelNum.textContent = String(fuel);
    const denom = Math.max(1, fuelStart);
    elFuelBar.style.width = `${(fuel / denom) * 100}%`;

    elRA.textContent = rollA ?? "â€“";
    // A-seat: hide B roll until choice/resolving/over
    elRB.textContent = (phase === "needChoice" || phase === "resolving" || phase === "over") ? (rollB ?? "â€“") : "â€“";

    btnRoll.disabled  = !(phase === "needRoll");
    btnAccel.disabled = !(phase === "needChoice");

    const canPass = (phase === "needChoice") && isPassAvailableA();
    btnPass.disabled  = !canPass;

    btnSpeed.textContent = `SPEED: ${speedMode.toUpperCase()}`;

    hintText.innerHTML =
      `<div><strong>ACCELERATE</strong>: move forward by your roll. You can pass through.</div>
       <div style="margin-top:6px"><strong>PASS</strong>: only when you are <em>behind</em> and within <span class="kbd">${PASS_RANGE}</span>. Hidden re-roll. Win â†’ you end <span class="kbd">1</span> ahead of B <em>after</em> B accelerates. Lose/tie â†’ you move <span class="kbd">+${PASS_FAIL_FWD}</span>.</div>
       <div style="margin-top:6px"><span class="kbd">Behind</span> has a <span class="kbd">25%</span> chance to roll double (2d6).</div>`;
  }

  // ---------- animation ----------
  function animateTo(target, forcedFlashText){
    anim.active = true;
    anim.t0 = performance.now();
    anim.ms = animMs();

    anim.from = {
      a:{pos: anim.a.pos},
      b:{pos: anim.b.pos}
    };
    anim.to = {
      a:{pos: target.posA},
      b:{pos: target.posB}
    };

    if(forcedFlashText){
      doFlash(forcedFlashText, forcedFlashText.includes("A") ? COLORS.A : COLORS.B);
    }

    requestAnimationFrame(tickAnim);
  }

  function tickAnim(){
    if(!anim.active) return;
    const u = clamp((performance.now() - anim.t0) / anim.ms, 0, 1);
    const s = u*u*(3-2*u);

    anim.a.pos  = anim.from.a.pos + (anim.to.a.pos - anim.from.a.pos) * s;
    anim.b.pos  = anim.from.b.pos + (anim.to.b.pos - anim.from.b.pos) * s;

    draw();

    if(u < 1){
      requestAnimationFrame(tickAnim);
    } else {
      anim.active = false;
      anim.a.pos = anim.to.a.pos;
      anim.b.pos = anim.to.b.pos;

      // reset
      choiceA = null;
      rollA = rollB = null;
      phase = "needRoll";
      syncUI();
      draw();
      endIfOver();
    }
  }

  // ---------- input ----------
  btnRoll.addEventListener('click', () => {
    if(phase !== "needRoll") return;

    rollA = movementRollFor(posA, posB);
    rollB = movementRollFor(posB, posA);

    phase = "needChoice";
    syncUI();
    draw();
  });

  function choose(action){
    if(phase !== "needChoice") return;
    choiceA = action;
    resolveTurn();
  }
  btnAccel.addEventListener('click', () => choose("ACCELERATE"));
  btnPass.addEventListener('click',  () => choose("PASS"));

  btnNew.addEventListener('click', () => newRace());
  btnSpeed.addEventListener('click', () => {
    speedMode = (speedMode === "normal") ? "fast" : "normal";
    syncUI();
  });

  // ---------- rendering ----------
  function gridToScreen(pt, pad){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const innerW = w - pad*2;
    const innerH = h - pad*2;
    const sx = innerW / (GRID_W - 1);
    const sy = innerH / (GRID_H - 1);
    return { x: pad + pt.x * sx, y: pad + pt.y * sy };
  }

  function laneNormalAt(i){
    const a = track[Math.max(0, i-1)];
    const b = track[Math.min(track.length-1, i+1)];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    let nx = -dy, ny = dx;
    const len = Math.hypot(nx, ny) || 1;
    nx /= len; ny /= len;
    return {nx, ny};
  }

  // cosmetic offset so you can see both tokens on the same "text line"
  function pointOnCosmeticLane(posFloat, which){
    const i0 = Math.floor(posFloat);
    const i1 = Math.min(TRACK_LEN, i0 + 1);
    const t = posFloat - i0;

    const p0 = track[i0], p1 = track[i1];
    const base = { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t };

    const {nx, ny} = laneNormalAt(i0);
    const sep = 0.35;
    const side = (which === "A" ? -1 : 1);
    return { x: base.x + nx * sep * side, y: base.y + ny * sep * side };
  }

  function drawTrack(pad){
    const center = track.map(pt => gridToScreen(pt, pad));
    const rail0 = [], rail1 = [];
    for(let i=0;i<track.length;i++){
      const {nx, ny} = laneNormalAt(i);
      const sep = 0.35;
      const p = track[i];
      rail0.push(gridToScreen({x:p.x + nx*sep*-1, y:p.y + ny*sep*-1}, pad));
      rail1.push(gridToScreen({x:p.x + nx*sep* 1, y:p.y + ny*sep* 1}, pad));
    }

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // glow underlay
    ctx.strokeStyle = COLORS.glow;
    ctx.lineWidth = 18;
    ctx.beginPath();
    ctx.moveTo(center[0].x, center[0].y);
    for(const p of center) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    // rails (kept for vibe)
    const stroke = (arr) => {
      ctx.strokeStyle = COLORS.rail;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(arr[0].x, arr[0].y);
      for(const p of arr) ctx.lineTo(p.x, p.y);
      ctx.stroke();
    };
    stroke(rail0); stroke(rail1);

    // labels
    const start = center[0];
    const finish = center[center.length-1];
    ctx.fillStyle = "rgba(233,238,247,.7)";
    ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("START", start.x + 10, start.y - 10);
    ctx.fillText("FINISH", finish.x + 10, finish.y - 10);

    // finish line (perpendicular to track)
    const finishIdx = track.length - 1;
    const finishPt = track[finishIdx];
    const {nx: fnx, ny: fny} = laneNormalAt(finishIdx);
    const finishSpan = 0.8;
    const finishA = gridToScreen(
      {x: finishPt.x + fnx * finishSpan, y: finishPt.y + fny * finishSpan},
      pad
    );
    const finishB = gridToScreen(
      {x: finishPt.x - fnx * finishSpan, y: finishPt.y - fny * finishSpan},
      pad
    );
    ctx.strokeStyle = "rgba(233,238,247,.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(finishA.x, finishA.y);
    ctx.lineTo(finishB.x, finishB.y);
    ctx.stroke();
  }

  function drawRacer(label, color, posFloat){
    const p = pointOnCosmeticLane(posFloat, label);
    const sp = gridToScreen(p, 34);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.arc(sp.x+2, sp.y+2, 14, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(sp.x, sp.y, 14, 0, Math.PI*2);
    ctx.fill();

    // letter
    ctx.fillStyle = "#0b0c10";
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, sp.x, sp.y + 0.5);
  }

  function drawHUD(){
    const w = canvas.getBoundingClientRect().width;

    // minimal upper-left: position + differential only
    const diff = posA - posB;
    const diffStr = (diff >= 0) ? `+${diff}` : `${diff}`;
    const text = `A ${posA}  (${diffStr})`;

    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(14, 14, 200, 44);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(14, 14, 200, 44);

    ctx.fillStyle = "rgba(233,238,247,.9)";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.font = "900 16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(text, 26, 36);

    // flash banner (center)
    if(flash){
      const t = (performance.now() - flash.t0) / flash.ms;
      if(t >= 1){ flash = null; return; }
      const alpha = (t < 0.15) ? (t/0.15) : (t > 0.85 ? (1-t)/0.15 : 1);

      ctx.fillStyle = `rgba(0,0,0,${0.40*alpha})`;
      ctx.fillRect(w/2 - 190, 18, 380, 44);
      ctx.strokeStyle = `rgba(255,255,255,${0.10*alpha})`;
      ctx.strokeRect(w/2 - 190, 18, 380, 44);

      ctx.fillStyle = flash.color;
      ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(flash.text, w/2, 40);
    }
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#0b0c10";
    ctx.fillRect(0,0,w,h);

    // subtle grid
    ctx.strokeStyle = "rgba(255,255,255,.035)";
    ctx.lineWidth = 1;
    for(let x=0;x<w;x+=24){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=24){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    drawTrack(34);
    drawRacer("A", COLORS.A, anim.a.pos);
    drawRacer("B", COLORS.B, anim.b.pos);
    drawHUD();
  }

  // ---------- bootstrap ----------
  fitCanvas();
  newRace();

})();
</script>
</body>
</html>

