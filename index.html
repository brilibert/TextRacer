<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Text Racer v4</title>
  <style>
    :root{
      --bg:#0e0f12;
      --panel:#14161b;
      --panel2:#0f1116;
      --ink:#e9eef7;
      --muted:#a8b0c0;
      --line:#2a2f3a;
      --btn:#1e2330;
      --btn2:#2a3142;
      --shadow: rgba(0,0,0,.35);
      --r:16px;
      --a:#52ffa8;
      --b:#ff5c7a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1000px 600px at 30% 10%, #1a1e27 0%, var(--bg) 55%) fixed;
      color:var(--ink);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex;
      justify-content:center;
      padding:18px;
    }
    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: 0 10px 30px var(--shadow);
      overflow:hidden;
    }
    .canvasWrap{padding:12px}
    canvas{
      width:100%;
      height:520px;
      display:block;
      border-radius:12px;
      background: #0b0c10;
      border:1px solid #232938;
    }
    .side{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .title{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding-bottom:10px;
      border-bottom:1px solid var(--line);
      margin-bottom:4px;
    }
    .title h1{
      font-size:14px;
      letter-spacing:.08em;
      margin:0;
      color:#dce6ff;
      text-transform:uppercase;
    }
    .sub{ color:var(--muted); font-size:12px; margin-top:4px; }
    .tag{ font-size:12px; color:var(--muted); }

    .row{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(255,255,255,.03);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      color:#dfe7ff;
      font-size:12px;
      min-width: 92px;
      justify-content:center;
    }
    .fuel{
      height:12px;
      background:#0b0c10;
      border:1px solid #232938;
      border-radius:999px;
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .fuel > div{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(82,255,168,.9), rgba(82,255,168,.45));
      border-right:1px solid rgba(255,255,255,.15);
      transition: width .25s ease;
    }
    .controls{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .btn{
      user-select:none;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border-radius:18px;
      padding:14px 12px;
      font-weight:800;
      letter-spacing:.06em;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height:54px;
      text-transform:uppercase;
    }
    .btn:active{transform: translateY(1px)}
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .btn.roll{ grid-column: 1 / -1; font-size:15px; }

    .hint{
      color:var(--muted);
      font-size:12px;
      padding:10px 12px;
      border:1px dashed rgba(255,255,255,.12);
      border-radius:14px;
      background: rgba(255,255,255,.02);
    }
    .log{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      min-height:160px;
      max-height:210px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      color:#d6ddf2;
      white-space:pre-wrap;
    }

    .miniBtns{ display:flex; gap:10px; }
    .mini{
      cursor:pointer;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--ink);
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
      flex:1;
    }
    .mini:active{transform: translateY(1px)}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      border:1px solid rgba(255,255,255,.18);
      padding:1px 6px;
      border-radius:8px;
      color:#dce6ff;
      background: rgba(255,255,255,.06);
    }

    @media (max-width: 900px){
      body{ padding:12px; }
      .wrap{ grid-template-columns: 1fr; gap:12px; }
      .side{ order: 0; }
      .canvasWrap{ order: 1; }
      canvas{ height: 60vh; min-height: 360px; }
      .controls{ grid-template-columns: 1fr; }
      .btn{ min-height:64px; font-size:16px; border-radius:20px; }
      .btn.roll{ font-size:16px; }
      .log{ max-height: 160px; min-height: 120px; }
      .mini{ padding:12px 12px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card side">
      <div class="title">
        <div>
          <h1>Pass / Accelerate</h1>
          <div class="sub">Aâ€™s-seat UI. One line. Fuel ends the race.</div>
        </div>
        <div class="tag" id="seedTag"></div>
      </div>

      <div class="row">
        <div style="flex:1">
          <div class="tag">Fuel (turns left)</div>
          <div style="margin-top:6px" class="fuel"><div id="fuelBar"></div></div>
        </div>
        <div class="pill"><span>â›½</span><strong id="fuelNum">0</strong></div>
      </div>

      <div class="row">
        <div class="tag">Movement roll</div>
        <div style="display:flex;gap:10px">
          <div class="pill" style="border-color: rgba(82,255,168,.35)">A: <strong id="rA">â€“</strong></div>
          <div class="pill" style="border-color: rgba(255,92,122,.35)">B: <strong id="rB">â€“</strong></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn roll" id="btnRoll">ðŸŽ² ROLL</button>
        <button class="btn" id="btnAccel" disabled>â¬†ï¸Ž ACCELERATE</button>
        <button class="btn" id="btnPass" disabled>â†Ÿ PASS</button>
      </div>

      <div class="hint" id="hintText"></div>

      <div class="miniBtns">
        <button class="mini" id="btnNew">NEW RACE</button>
        <button class="mini" id="btnSpeed">SPEED: NORMAL</button>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (rng, a, b) => Math.floor(rng() * (b - a + 1)) + a;

  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }

  // ---------- config ----------
  const TRACK_LEN = 60;
  const FUEL_MAX  = 22;

  // PASS: eligibility + overtake
  const PASS_RANGE = 4;         // must be within 4 (and behind)
  const CATCHUP_CHANCE = 0.25;  // trailing racer on MOVEMENT roll may double their movement roll

  // Visual path randomness
  const GRID_W = 26, GRID_H = 14;

  const COLORS = {
    A: getComputedStyle(document.documentElement).getPropertyValue('--a').trim(),
    B: getComputedStyle(document.documentElement).getPropertyValue('--b').trim(),
    rail: "#2a3142",
    glow: "rgba(82,255,168,.08)"
  };

  let speedMode = "normal";
  const animMs = () => speedMode === "fast" ? 140 : 260;

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const seedTag = document.getElementById('seedTag');
  const elFuelNum = document.getElementById('fuelNum');
  const elFuelBar = document.getElementById('fuelBar');
  const elRA = document.getElementById('rA');
  const elRB = document.getElementById('rB');
  const elLog = document.getElementById('log');
  const hintText = document.getElementById('hintText');

  const btnRoll = document.getElementById('btnRoll');
  const btnAccel = document.getElementById('btnAccel');
  const btnPass  = document.getElementById('btnPass');
  const btnNew   = document.getElementById('btnNew');
  const btnSpeed = document.getElementById('btnSpeed');

  function log(line){
    elLog.textContent = (line + "\n" + elLog.textContent).slice(0, 5200);
  }

  // ---------- state ----------
  let rng, seed;
  let track = [];

  let posA = 0, posB = 0;
  let fuel = FUEL_MAX;

  // movement rolls (base vs effective)
  let baseRollA = null, baseRollB = null;
  let rollA = null, rollB = null;
  let catchupA = false, catchupB = false;

  let phase = "needRoll"; // needRoll -> needChoice -> anim/resolving -> needRoll
  let choiceA = null;
  let choiceB = null; // CPU decision per turn

  // animation floats along the track parameter
  const anim = {
    active:false,
    t0:0,
    ms:240,
    from:{ a:0, b:0 },
    to:{ a:0, b:0 },
    a:0,
    b:0,
  };

  // flash banner in HUD
  let flash = null;
  function doFlash(text, color){
    flash = {text, color, t0: performance.now(), ms: 900};
  }

  // ---------- canvas sizing ----------
  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  // ---------- track generation (a wiggly single line) ----------
  function generateTrack(){
    const used = new Set();
    const start = {x:2, y: Math.floor(GRID_H/2)};
    let p = {x:start.x, y:start.y};
    used.add(`${p.x},${p.y}`);
    const pts = [p];

    let lastDir = {dx:1, dy:0};

    for(let i=0;i<TRACK_LEN;i++){
      const candidates = [
        {dx: 1, dy: 0, w: 6},
        {dx: 0, dy:-1, w: 2},
        {dx: 0, dy: 1, w: 2},
        {dx:-1, dy: 0, w: 0.4},
      ];
      // discourage immediate reversal
      for(const c of candidates){
        if(c.dx === -lastDir.dx && c.dy === -lastDir.dy) c.w *= 0.15;
      }

      const feas = [];
      for(const c of candidates){
        const nx = p.x + c.dx, ny = p.y + c.dy;
        if(nx < 1 || nx > GRID_W-2 || ny < 1 || ny > GRID_H-2) continue;
        const key = `${nx},${ny}`;
        if(used.has(key)) continue;
        feas.push({nx, ny, dx:c.dx, dy:c.dy, w:c.w});
      }
      if(!feas.length) return null;

      let total = feas.reduce((s,f)=>s+f.w,0);
      let r = rng() * total;
      let pick = feas[0];
      for(const f of feas){
        r -= f.w;
        if(r <= 0){ pick = f; break; }
      }
      p = {x: pick.nx, y: pick.ny};
      used.add(`${p.x},${p.y}`);
      pts.push(p);
      lastDir = {dx: pick.dx, dy: pick.dy};
    }
    return pts;
  }

  function newRace(forcedSeed){
    seed = (forcedSeed ?? Math.floor(Math.random()*1e9)) >>> 0;
    rng = mulberry32(seed);

    let t = null;
    for(let k=0;k<30;k++){
      t = generateTrack();
      if(t) break;
      seed = (seed + 1337) >>> 0;
      rng = mulberry32(seed);
    }
    if(!t){
      // fallback straight line
      t = Array.from({length: TRACK_LEN+1}, (_,i)=>({x:2+i, y:Math.floor(GRID_H/2)}));
    }
    track = t;

    posA = 0; posB = 0;
    fuel = FUEL_MAX;

    baseRollA = baseRollB = null;
    rollA = rollB = null;
    catchupA = catchupB = false;

    phase = "needRoll";
    choiceA = choiceB = null;

    anim.active = false;
    anim.a = posA; anim.b = posB;
    anim.from = {a:posA, b:posB};
    anim.to   = {a:posA, b:posB};

    seedTag.textContent = `SEED ${seed}`;
    elLog.textContent = "";
    log("NEW RACE");
    syncUI();
    draw();
  }

  // ---------- rules ----------
  function isAPassEligible(){
    // NEW: A can attempt PASS if A is behind and within PASS_RANGE (no roll comparison).
    if(phase !== "needChoice") return false;
    if(rollA == null || rollB == null) return false;
    const behind = posA < posB;
    const within = (posB - posA) <= PASS_RANGE;
    return behind && within;
  }

  function applyCatchupDoubles(){
    catchupA = false;
    catchupB = false;

    if(posA === posB) return;
    const trailing = (posA < posB) ? "A" : "B";
    if(rng() < CATCHUP_CHANCE){
      if(trailing === "A"){ catchupA = true; rollA = baseRollA * 2; }
      else { catchupB = true; rollB = baseRollB * 2; }
    }
  }

  function cpuChooseAction(){
    // CPU is intentionally shallow and beatable.
    // CPU can PASS if B is behind and within PASS_RANGE (no roll comparison).
    const bBehind = posB < posA;
    const gap = posA - posB; // positive when B is behind
    const bWithin = gap <= PASS_RANGE;
    const bCanPass = bBehind && bWithin;

    // If ACCELERATE would already overtake A (end ahead), never choose PASS.
    // end ahead means: posB + rollB > posA  <=>  rollB > gap
    const accelWouldOvertake = bBehind && (rollB > gap);

    if(bCanPass && !accelWouldOvertake){
      let p = 0.22;
      if(fuel <= 8) p += 0.10;
      if(gap === 1) p += 0.12; // right on the bumper
      p = clamp(p, 0.18, 0.55);
      return (rng() < p) ? "PASS" : "ACCELERATE";
    }
    return "ACCELERATE";
  }

  // ---------- UI ----------
  function rollDisplayText(player){
    const isA = player === "A";
    const base = isA ? baseRollA : baseRollB;
    const eff  = isA ? rollA : rollB;
    const cUp  = isA ? catchupA : catchupB;
    if(base == null || eff == null) return "â€“";
    return cUp ? `${base}â†’${eff}` : String(eff);
  }

  function syncUI(){
    elFuelNum.textContent = String(fuel);
    elFuelBar.style.width = `${(fuel / FUEL_MAX) * 100}%`;

    elRA.textContent = rollDisplayText("A");
    elRB.textContent = (phase === "needChoice" || phase === "resolving" || phase === "over") ? rollDisplayText("B") : "â€“";

    btnRoll.disabled  = !(phase === "needRoll");
    btnAccel.disabled = !(phase === "needChoice");
    btnPass.disabled  = !(phase === "needChoice") || !isAPassEligible();

    btnSpeed.textContent = `SPEED: ${speedMode.toUpperCase()}`;

    hintText.innerHTML =
      `<div><strong>ACCELERATE</strong>: move by your movement roll.</div>
       <div style="margin-top:6px"><strong>PASS</strong>: if A is <span class="kbd">behind</span> and within <span class="kbd">${PASS_RANGE}</span>, you may try. PASS forfeits movement and rolls a separate d6 vs the opponent. Win â†’ jump to <span class="kbd">other+1</span>. Lose/tie â†’ <span class="kbd">stay</span>.</div>
       <div style="margin-top:6px"><strong>CATCH-UP</strong>: whoever is behind on ROLL has a <span class="kbd">1/4</span> chance to double their movement roll.</div>`;
  }

  function endIfOver(){
    if (fuel <= 0 || posA >= TRACK_LEN || posB >= TRACK_LEN){
      phase = "over";
      btnRoll.disabled = btnAccel.disabled = btnPass.disabled = true;

      const winner = (posA === posB) ? "TIE" : (posA > posB ? "A WINS" : "B WINS");
      log(`â€” ${winner} â€”  (A:${posA}  B:${posB})`);
      doFlash(winner, winner === "A WINS" ? COLORS.A : winner === "B WINS" ? COLORS.B : "#dce6ff");
      syncUI();
      draw();
      return true;
    }
    return false;
  }

  // ---------- animation ----------
  function animateTo(aTarget, bTarget){
    anim.active = true;
    anim.t0 = performance.now();
    anim.ms = animMs();

    anim.from = { a: anim.a, b: anim.b };
    anim.to   = { a: aTarget, b: bTarget };

    requestAnimationFrame(tickAnim);
  }

  function tickAnim(){
    if(!anim.active) return;
    const u = clamp((performance.now() - anim.t0) / anim.ms, 0, 1);
    const s = u*u*(3-2*u);

    anim.a = anim.from.a + (anim.to.a - anim.from.a) * s;
    anim.b = anim.from.b + (anim.to.b - anim.from.b) * s;

    draw();

    if(u < 1){
      requestAnimationFrame(tickAnim);
    } else {
      anim.active = false;
      anim.a = anim.to.a;
      anim.b = anim.to.b;

      // reset for next turn
      choiceA = choiceB = null;
      baseRollA = baseRollB = null;
      rollA = rollB = null;
      catchupA = catchupB = false;

      phase = "needRoll";
      syncUI();
      draw();
      endIfOver();
    }
  }

  // ---------- rendering ----------
  function gridToScreen(pt, pad){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const innerW = w - pad*2;
    const innerH = h - pad*2;
    const sx = innerW / (GRID_W - 1);
    const sy = innerH / (GRID_H - 1);
    return { x: pad + pt.x * sx, y: pad + pt.y * sy };
  }

  function pointOnTrack(posFloat){
    const i0 = Math.floor(posFloat);
    const i1 = Math.min(TRACK_LEN, i0 + 1);
    const t = posFloat - i0;

    const p0 = track[i0], p1 = track[i1];
    return { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t };
  }

  function drawTrack(pad){
    const pts = track.map(pt => gridToScreen(pt, pad));

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.strokeStyle = COLORS.glow;
    ctx.lineWidth = 18;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(const p of pts) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    ctx.strokeStyle = COLORS.rail;
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(const p of pts) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    const start = pts[0];
    const finish = pts[pts.length-1];

    ctx.fillStyle = "rgba(233,238,247,.7)";
    ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("START", start.x + 10, start.y - 10);
    ctx.fillText("FINISH", finish.x + 10, finish.y - 10);

    ctx.strokeStyle = "rgba(233,238,247,.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(finish.x - 12, finish.y - 12);
    ctx.lineTo(finish.x + 12, finish.y + 12);
    ctx.stroke();
  }

  function drawRacer(label, color, posFloat, nudge){
    const p = pointOnTrack(posFloat);
    const sp = gridToScreen(p, 34);

    const x = sp.x;
    const y = sp.y + nudge;

    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.arc(x+2, y+2, 14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, 14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "#0b0c10";
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, x, y + 0.5);
  }

  function drawHUD(){
    const w = canvas.getBoundingClientRect().width;

    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(14, 14, 330, 54);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(14, 14, 330, 54);

    ctx.fillStyle = "rgba(233,238,247,.85)";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`FUEL ${fuel}/${FUEL_MAX}`, 26, 24);

    const diff = posA - posB;
    const diffText = diff === 0 ? "TIE" : (diff > 0 ? `A+${diff}` : `B+${Math.abs(diff)}`);
    ctx.font = "900 16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`A=${posA}  B=${posB}  (${diffText})`, 26, 40);

    if(flash){
      const t = (performance.now() - flash.t0) / flash.ms;
      if(t >= 1){ flash = null; return; }
      const alpha = (t < 0.15) ? (t/0.15) : (t > 0.85 ? (1-t)/0.15 : 1);

      ctx.fillStyle = `rgba(0,0,0,${0.40*alpha})`;
      ctx.fillRect(w/2 - 200, 18, 400, 44);
      ctx.strokeStyle = `rgba(255,255,255,${0.10*alpha})`;
      ctx.strokeRect(w/2 - 200, 18, 400, 44);

      ctx.fillStyle = flash.color;
      ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(flash.text, w/2, 40);
    }
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#0b0c10";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(255,255,255,.035)";
    ctx.lineWidth = 1;
    for(let x=0;x<w;x+=24){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=24){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    drawTrack(34);
    drawRacer("A", COLORS.A, anim.a, -10);
    drawRacer("B", COLORS.B, anim.b,  10);
    drawHUD();
  }

  // ---------- turn resolution ----------
  function movementRollText(player){
    const isA = player === "A";
    const base = isA ? baseRollA : baseRollB;
    const eff  = isA ? rollA : rollB;
    const cUp  = isA ? catchupA : catchupB;
    if(base == null || eff == null) return "â€“";
    return cUp ? `${base}â†’${eff}` : `r${eff}`;
  }

  function resolveTurn(){
    phase = "resolving";
    syncUI();

    const startA = posA, startB = posB;
    const actionA = choiceA;
    const actionB = choiceB;

    let nextA = startA;
    let nextB = startB;

    // B move
    if(actionB === "ACCELERATE"){
      nextB = clamp(startB + rollB, 0, TRACK_LEN);
    } else {
      const bBehind = startB < startA;
      const bWithin = (startA - startB) <= PASS_RANGE;
      if(bBehind && bWithin){
        const bPassRoll = randInt(rng, 1, 6);
        const aDefRoll  = randInt(rng, 1, 6);
        log(`B PASS-ROLL ${bPassRoll} vs A ${aDefRoll}`);
        if(bPassRoll > aDefRoll){
          nextB = clamp(startA + 1, 0, TRACK_LEN);
          doFlash("B PASS SUCCESS", COLORS.B);
          log("B PASS SUCCESS â†’ B jumps to A+1");
        } else {
          nextB = startB;
          doFlash("B PASS FAIL", COLORS.A);
          log("B PASS FAIL â†’ B stays");
        }
      } else {
        nextB = startB;
        log("B PASS not eligible â†’ B stays");
      }
    }

    // A move
    if(actionA === "ACCELERATE"){
      nextA = clamp(startA + rollA, 0, TRACK_LEN);
    } else {
      const aBehind = startA < startB;
      const aWithin = (startB - startA) <= PASS_RANGE;
      if(aBehind && aWithin){
        const aPassRoll = randInt(rng, 1, 6);
        const bDefRoll  = randInt(rng, 1, 6);
        log(`A PASS-ROLL ${aPassRoll} vs B ${bDefRoll}`);
        if(aPassRoll > bDefRoll){
          nextA = clamp(startB + 1, 0, TRACK_LEN);
          doFlash("A PASS SUCCESS", COLORS.A);
          log("A PASS SUCCESS â†’ A jumps to B+1");
        } else {
          nextA = startA;
          doFlash("A PASS FAIL", COLORS.B);
          log("A PASS FAIL â†’ A stays");
        }
      } else {
        nextA = startA;
        log("A PASS not eligible â†’ A stays");
      }
    }

    fuel = Math.max(0, fuel - 1);

    log(`A:${actionA.padEnd(10)} ${movementRollText("A").padEnd(6)} | B:${actionB.padEnd(10)} ${movementRollText("B")}`);
    if(catchupA) log(`CATCH-UP: A movement roll doubled (${baseRollA}â†’${rollA})`);
    if(catchupB) log(`CATCH-UP: B movement roll doubled (${baseRollB}â†’${rollB})`);
    log(`MOVE: A ${startA}â†’${nextA} | B ${startB}â†’${nextB}`);

    posA = nextA;
    posB = nextB;

    syncUI();
    animateTo(posA, posB);
  }

  // ---------- input ----------
  btnRoll.addEventListener('click', () => {
    if(phase !== "needRoll") return;

    baseRollA = randInt(rng, 1, 6);
    baseRollB = randInt(rng, 1, 6);

    rollA = baseRollA;
    rollB = baseRollB;

    applyCatchupDoubles();

    if(catchupA) doFlash(`CATCH-UP: A ${baseRollA}â†’${rollA}`, COLORS.A);
    if(catchupB) doFlash(`CATCH-UP: B ${baseRollB}â†’${rollB}`, COLORS.B);

    choiceB = cpuChooseAction();
    phase = "needChoice";
    syncUI();
    draw();
  });

  function choose(action){
    if(phase !== "needChoice") return;
    choiceA = action;
    resolveTurn();
  }

  btnAccel.addEventListener('click', () => choose("ACCELERATE"));
  btnPass.addEventListener('click',  () => choose("PASS"));

  btnNew.addEventListener('click', () => newRace());
  btnSpeed.addEventListener('click', () => {
    speedMode = (speedMode === "normal") ? "fast" : "normal";
    syncUI();
  });

  // ---------- bootstrap ----------
  fitCanvas();
  newRace();
})();
</script>
</body>
</html>
