<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PASS / ACCELERATE</title>
  <style>
    :root{
      --bg:#0e0f12;
      --panel:#14161b;
      --panel2:#0f1116;
      --ink:#e9eef7;
      --muted:#a8b0c0;
      --line:#2a2f3a;
      --btn:#1e2330;
      --btn2:#2a3142;
      --shadow: rgba(0,0,0,.35);
      --r:16px;
      --a:#52ffa8;
      --b:#ff5c7a;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1000px 600px at 30% 10%, #1a1e27 0%, var(--bg) 55%) fixed;
      color:var(--ink);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex;
      justify-content:center;
      padding:18px;
    }

    .wrap{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:16px;
      align-items:start;
    }

    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: 0 10px 30px var(--shadow);
      overflow:hidden;
    }

    .canvasWrap{padding:12px}
    canvas{
      width:100%;
      height:520px;
      display:block;
      border-radius:12px;
      background: #0b0c10;
      border:1px solid #232938;
    }

    .side{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .title{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding-bottom:10px;
      border-bottom:1px solid var(--line);
      margin-bottom:4px;
    }
    .title h1{
      font-size:14px;
      letter-spacing:.08em;
      margin:0;
      color:#dce6ff;
      text-transform:uppercase;
    }
    .sub{ color:var(--muted); font-size:12px; margin-top:4px; }
    .tag{ font-size:12px; color:var(--muted); }

    .row{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(255,255,255,.03);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      color:#dfe7ff;
      font-size:12px;
      min-width: 92px;
      justify-content:center;
    }
    .fuel{
      height:12px;
      background:#0b0c10;
      border:1px solid #232938;
      border-radius:999px;
      overflow:hidden;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    }
    .fuel > div{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(82,255,168,.9), rgba(82,255,168,.45));
      border-right:1px solid rgba(255,255,255,.15);
      transition: width .25s ease;
    }

    .controls{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    .btn{
      user-select:none;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border-radius:18px;
      padding:14px 12px;
      font-weight:800;
      letter-spacing:.06em;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-height:54px;
      text-transform:uppercase;
    }
    .btn:active{transform: translateY(1px)}
    .btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
    .btn.roll{ grid-column: 1 / -1; font-size:15px; }

    .hint{
      color:var(--muted);
      font-size:12px;
      padding:10px 12px;
      border:1px dashed rgba(255,255,255,.12);
      border-radius:14px;
      background: rgba(255,255,255,.02);
    }

    .log{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      min-height:160px;
      max-height:210px;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      color:#d6ddf2;
      white-space:pre-wrap;
    }

    .miniBtns{ display:flex; gap:10px; }
    .mini{
      cursor:pointer;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color:var(--ink);
      font-weight:700;
      letter-spacing:.04em;
      text-transform:uppercase;
      flex:1;
    }
    .mini:active{transform: translateY(1px)}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      border:1px solid rgba(255,255,255,.18);
      padding:1px 6px;
      border-radius:8px;
      color:#dce6ff;
      background: rgba(255,255,255,.06);
    }

    @media (max-width: 900px){
      body{ padding:12px; }
      .wrap{
        grid-template-columns: 1fr;
        gap:12px;
      }
      .side{ order: 0; }
      .canvasWrap{ order: 1; }

      canvas{ height: 60vh; min-height: 360px; }

      .controls{
        grid-template-columns: 1fr;
      }
      .btn{
        min-height:64px;
        font-size:16px;
        border-radius:20px;
      }
      .btn.roll{ font-size:16px; }

      .log{
        max-height: 160px;
        min-height: 120px;
      }
      .mini{
        padding:12px 12px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card side">
      <div class="title">
        <div>
          <h1>Pass / Accelerate</h1>
          <div class="sub">Aâ€™s-seat UI. Two lanes. Fuel ends the race.</div>
        </div>
        <div class="tag" id="seedTag"></div>
      </div>

      <div class="row">
        <div style="flex:1">
          <div class="tag">Fuel (turns left)</div>
          <div style="margin-top:6px" class="fuel"><div id="fuelBar"></div></div>
        </div>
        <div class="pill"><span>â›½</span><strong id="fuelNum">0</strong></div>
      </div>

      <div class="row">
        <div class="tag">Current roll</div>
        <div style="display:flex;gap:10px">
          <div class="pill" style="border-color: rgba(82,255,168,.35)">A: <strong id="rA">â€“</strong></div>
          <div class="pill" style="border-color: rgba(255,92,122,.35)">B: <strong id="rB">â€“</strong></div>
        </div>
      </div>

      <div class="controls">
        <button class="btn roll" id="btnRoll">ðŸŽ² ROLL</button>
        <button class="btn" id="btnAccel" disabled>â¬†ï¸Ž ACCELERATE</button>
        <button class="btn" id="btnPass" disabled>â†”ï¸Ž PASS</button>
      </div>

      <div class="hint" id="hintText"></div>

      <div class="miniBtns">
        <button class="mini" id="btnNew">NEW RACE</button>
        <button class="mini" id="btnSpeed">SPEED: NORMAL</button>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

<script>
(() => {
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const randInt = (rng, a, b) => Math.floor(rng() * (b - a + 1)) + a;

  function mulberry32(seed){
    let a = seed >>> 0;
    return function(){
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
  }

  // ---------- config ----------
  const TRACK_LEN = 60;
  const FUEL_MAX  = 22;
  const PASS_RANGE = 3;
  const PASS_FAIL_FWD = 2;

  // Rubber-band: trailing racer has 25% chance of doubled roll each turn.
  const CATCHUP_CHANCE = 0.25;

  const GRID_W = 24, GRID_H = 14;

  const COLORS = {
    A: getComputedStyle(document.documentElement).getPropertyValue('--a').trim(),
    B: getComputedStyle(document.documentElement).getPropertyValue('--b').trim(),
    rail: "#2a3142",
    glow: "rgba(82,255,168,.08)"
  };

  let speedMode = "normal";
  const animMs = () => speedMode === "fast" ? 120 : 240;

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const seedTag = document.getElementById('seedTag');
  const elFuelNum = document.getElementById('fuelNum');
  const elFuelBar = document.getElementById('fuelBar');
  const elRA = document.getElementById('rA');
  const elRB = document.getElementById('rB');
  const elLog = document.getElementById('log');
  const hintText = document.getElementById('hintText');

  const btnRoll = document.getElementById('btnRoll');
  const btnAccel = document.getElementById('btnAccel');
  const btnPass  = document.getElementById('btnPass');
  const btnNew   = document.getElementById('btnNew');
  const btnSpeed = document.getElementById('btnSpeed');

  function log(line){
    elLog.textContent = (line + "\n" + elLog.textContent).slice(0, 3800);
  }

  const laneName = (n) => n === 0 ? "L" : "R";

  // ---------- game state ----------
  let rng, seed;
  let track = [];
  let posA = 0, posB = 0;
  let laneA = 0, laneB = 1;
  let fuel = FUEL_MAX;

  // Base roll vs effective roll (effective may be doubled)
  let baseRollA = null, baseRollB = null;
  let rollA = null, rollB = null;

  // Catch-up flags (for display/logging)
  let catchupA = false, catchupB = false;

  let choiceA = null, choiceB = null;
  let phase = "needRoll";

  const anim = {
    active:false,
    t0:0,
    ms:240,
    from:{ a:{pos:0,lane:0}, b:{pos:0,lane:1} },
    to:{ a:{pos:0,lane:0},   b:{pos:0,lane:1} },
    a:{pos:0,lane:0},
    b:{pos:0,lane:1},
  };

  let flash = null;
  function doFlash(text, color){
    flash = {text, color, t0: performance.now(), ms: 900};
  }

  function fitCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  // ---------- track generation ----------
  function generateTrack(){
    const used = new Set();
    const start = {x:2, y: Math.floor(GRID_H/2)};
    let p = {x:start.x, y:start.y};
    used.add(`${p.x},${p.y}`);
    const pts = [p];

    let lastDir = {dx:1, dy:0};

    for(let i=0;i<TRACK_LEN;i++){
      const candidates = [
        {dx: 1, dy: 0, w: 5},
        {dx: 0, dy:-1, w: 2},
        {dx: 0, dy: 1, w: 2},
        {dx:-1, dy: 0, w: 0.6},
      ];
      for(const c of candidates){
        if(c.dx === -lastDir.dx && c.dy === -lastDir.dy) c.w *= 0.25;
      }

      const feas = [];
      for(const c of candidates){
        const nx = p.x + c.dx, ny = p.y + c.dy;
        if(nx < 1 || nx > GRID_W-2 || ny < 1 || ny > GRID_H-2) continue;
        const key = `${nx},${ny}`;
        if(used.has(key)) continue;
        let w = c.w * (c.dx === 1 ? 1.0 + i/60 : 1.0);
        feas.push({nx, ny, dx:c.dx, dy:c.dy, w});
      }
      if(!feas.length) return null;

      let total = feas.reduce((s,f)=>s+f.w,0);
      let r = rng() * total;
      let pick = feas[0];
      for(const f of feas){
        r -= f.w;
        if(r <= 0){ pick = f; break; }
      }
      p = {x: pick.nx, y: pick.ny};
      used.add(`${p.x},${p.y}`);
      pts.push(p);
      lastDir = {dx: pick.dx, dy: pick.dy};
    }
    return pts;
  }

  function newRace(forcedSeed){
    seed = (forcedSeed ?? Math.floor(Math.random()*1e9)) >>> 0;
    rng = mulberry32(seed);

    let t = null;
    for(let k=0;k<25;k++){
      t = generateTrack();
      if(t) break;
      seed = (seed + 1337) >>> 0;
      rng = mulberry32(seed);
    }
    if(!t){
      t = Array.from({length: TRACK_LEN+1}, (_,i)=>({x:2+i, y:Math.floor(GRID_H/2)}));
    }
    track = t;

    posA = 0; laneA = 0;
    posB = 0; laneB = 1;

    fuel = FUEL_MAX;

    baseRollA = baseRollB = null;
    rollA = rollB = null;
    catchupA = catchupB = false;

    choiceA = choiceB = null;
    phase = "needRoll";

    anim.active = false;
    anim.a.pos = posA; anim.a.lane = laneA;
    anim.b.pos = posB; anim.b.lane = laneB;

    seedTag.textContent = `SEED ${seed}`;
    elLog.textContent = "";
    log("NEW RACE");
    syncUI();
    draw();
  }

  // ---------- movement rules ----------
  // Only adjustment: if destination occupied (same lane & same index), back up by 1 (never backwards).
  function applyDestinationOccupancy(player, cur, laneAfter, intendedTarget){
    const isA = player === "A";
    const myStartPos = isA ? cur.posA : cur.posB;
    const otherPos   = isA ? cur.posB : cur.posA;
    const otherLane  = isA ? cur.laneB : cur.laneA;

    let target = clamp(intendedTarget, 0, TRACK_LEN);
    let adjusted = false;
    let reason = null;

    if(otherLane === laneAfter && otherPos === target){
      adjusted = true;
      reason = "occupied";
      target = target - 1;
      if(target < myStartPos) target = myStartPos;
    }
    return {pos: target, adjusted, reason};
  }

  function moveAccelerate(player, cur){
    const isA = player === "A";
    const myPos  = isA ? cur.posA  : cur.posB;
    const myLane = isA ? cur.laneA : cur.laneB;
    const myRoll = isA ? rollA : rollB;

    const intended = Math.min(TRACK_LEN, myPos + myRoll);
    const applied = applyDestinationOccupancy(player, cur, myLane, intended);
    return { intendedTarget: intended, ...applied };
  }

  function moveForwardFixed(player, cur, steps){
    const isA = player === "A";
    const myPos  = isA ? cur.posA  : cur.posB;
    const myLane = isA ? cur.laneA : cur.laneB;

    const intended = Math.min(TRACK_LEN, myPos + steps);
    const applied = applyDestinationOccupancy(player, cur, myLane, intended);
    return { intendedTarget: intended, ...applied };
  }

  // ---------- pass rules ----------
  function tryPass(player, cur){
    const isA = player === "A";
    const myLane = isA ? cur.laneA : cur.laneB;
    const myPos  = isA ? cur.posA  : cur.posB;
    const myRoll = isA ? rollA : rollB;

    const oth = isA
      ? {pos:cur.posB, lane:cur.laneB, roll:rollB}
      : {pos:cur.posA, lane:cur.laneA, roll:rollA};

    if (Math.abs(myPos - oth.pos) > PASS_RANGE) return {ok:false, lane:myLane, reason:"range"};
    if (myRoll <= oth.roll) return {ok:false, lane:myLane, reason:"roll"};

    const newLane = myLane === 0 ? 1 : 0;

    if (oth.lane === newLane && oth.pos === myPos) return {ok:false, lane:myLane, reason:"occupied"};

    return {ok:true, lane:newLane, reason:null};
  }

  function cpuChoose(){
    const close = Math.abs(posB - posA) <= PASS_RANGE;
    const behind = posB < posA;

    let pPass = 0.06;
    if(close) pPass += 0.16;
    if(behind && close && rollB >= 5) pPass += 0.12;
    if(fuel <= 6 && behind && close) pPass += 0.10;

    if(!close) pPass = 0.02;
    pPass = clamp(pPass, 0.02, 0.55);
    return (rng() < pPass) ? "PASS" : "ACCELERATE";
  }

  // ---------- UI ----------
  function rollDisplayText(player){
    const isA = player === "A";
    const base = isA ? baseRollA : baseRollB;
    const eff  = isA ? rollA : rollB;
    const cUp  = isA ? catchupA : catchupB;
    if(base == null || eff == null) return "â€“";
    return cUp ? `${base}â†’${eff}` : String(eff);
  }

  function syncUI(){
    elFuelNum.textContent = String(fuel);
    elFuelBar.style.width = `${(fuel / FUEL_MAX) * 100}%`;

    elRA.textContent = rollDisplayText("A");
    elRB.textContent = (phase === "needChoice" || phase === "resolving" || phase === "over") ? rollDisplayText("B") : "â€“";

    btnRoll.disabled  = !(phase === "needRoll");
    btnAccel.disabled = !(phase === "needChoice");
    btnPass.disabled  = !(phase === "needChoice");

    btnSpeed.textContent = `SPEED: ${speedMode.toUpperCase()}`;

    hintText.innerHTML =
      `<div><strong>ACCELERATE</strong>: move exactly your roll (clamped). Only adjustment: if destination occupied, you stop 1 short.</div>
       <div style="margin-top:6px"><strong>PASS</strong>: within <span class="kbd">${PASS_RANGE}</span> spaces and roll &gt; Bâ€™s roll. If PASS fails, you still move <span class="kbd">+${PASS_FAIL_FWD}</span>.</div>
       <div style="margin-top:6px"><strong>CATCH-UP</strong>: whoever is behind on ROLL has a <span class="kbd">1/4</span> chance to double their roll.</div>`;
  }

  function endIfOver(){
    if (fuel <= 0 || posA >= TRACK_LEN || posB >= TRACK_LEN){
      phase = "over";
      btnRoll.disabled = btnAccel.disabled = btnPass.disabled = true;

      const winner = (posA === posB) ? "TIE" : (posA > posB ? "A WINS" : "B WINS");
      log(`â€” ${winner} â€”  (A:${posA}  B:${posB})`);
      doFlash(winner, winner === "A WINS" ? COLORS.A : winner === "B WINS" ? COLORS.B : "#dce6ff");
      syncUI();
      draw();
      return true;
    }
    return false;
  }

  // ---------- animation ----------
  function animateTo(target){
    anim.active = true;
    anim.t0 = performance.now();
    anim.ms = animMs();

    anim.from = {
      a:{pos: anim.a.pos, lane: anim.a.lane},
      b:{pos: anim.b.pos, lane: anim.b.lane}
    };
    anim.to = {
      a:{pos: target.posA, lane: target.laneA},
      b:{pos: target.posB, lane: target.laneB}
    };

    requestAnimationFrame(tickAnim);
  }

  function tickAnim(){
    if(!anim.active) return;
    const u = clamp((performance.now() - anim.t0) / anim.ms, 0, 1);
    const s = u*u*(3-2*u);

    anim.a.pos  = anim.from.a.pos  + (anim.to.a.pos  - anim.from.a.pos)  * s;
    anim.a.lane = anim.from.a.lane + (anim.to.a.lane - anim.from.a.lane) * s;
    anim.b.pos  = anim.from.b.pos  + (anim.to.b.pos  - anim.from.b.pos)  * s;
    anim.b.lane = anim.from.b.lane + (anim.to.b.lane - anim.from.b.lane) * s;

    draw();

    if(u < 1){
      requestAnimationFrame(tickAnim);
    } else {
      anim.active = false;
      anim.a.pos = anim.to.a.pos; anim.a.lane = anim.to.a.lane;
      anim.b.pos = anim.to.b.pos; anim.b.lane = anim.to.b.lane;

      choiceA = choiceB = null;

      baseRollA = baseRollB = null;
      rollA = rollB = null;
      catchupA = catchupB = false;

      phase = "needRoll";
      syncUI();
      draw();
      endIfOver();
    }
  }

  // ---------- logging helpers ----------
  function passFailTextA(reason){
    if(reason === "range") return `A PASS FAIL: TOO FAR`;
    if(reason === "roll") return `A PASS FAIL: SLOWER`;
    return `A PASS FAIL: BLOCKED`;
  }

  function logMove(player, kind, rollText, startPos, startLane, intendedTarget, endPos, endLane, adjusted, adjReason){
    const lanePart = (startLane === endLane) ? laneName(endLane) : `${laneName(startLane)}â†’${laneName(endLane)}`;
    let s = `${player} ${kind} ${lanePart} ${startPos}â†’${intendedTarget} (${rollText})`;
    if(adjusted){
      const why = (adjReason === "occupied") ? "DEST OCCUPIED" : String(adjReason || "ADJ");
      s += `  adjâ†’${endPos} [${why}]`;
    }
    return s;
  }

  // ---------- resolve turn ----------
  function resolveTurn(){
    phase = "resolving";
    syncUI();

    const start = {posA, laneA, posB, laneB};
    const cur = {posA, laneA, posB, laneB};
    const next = {posA, laneA, posB, laneB};

    const bothPass = (choiceA === "PASS" && choiceB === "PASS");
    let noteA = null;

    let aPassFailed = false;
    let bPassFailed = false;

    // PASS phase (lane changes only)
    if(bothPass){
      const resA = tryPass("A", cur);
      const resB = tryPass("B", cur);

      if(resA.ok){ next.laneA = resA.lane; noteA = "A PASS SUCCESS"; }
      else { noteA = passFailTextA(resA.reason); aPassFailed = true; }

      if(resB.ok){ next.laneB = resB.lane; }
      else { bPassFailed = true; }

      if(next.posA === next.posB && next.laneA === next.laneB){
        next.laneB = cur.laneB;
      }
    } else {
      if(choiceA === "PASS"){
        const resA = tryPass("A", cur);
        if(resA.ok){ next.laneA = resA.lane; noteA = "A PASS SUCCESS"; }
        else { noteA = passFailTextA(resA.reason); aPassFailed = true; }
      }
      if(choiceB === "PASS"){
        const resB = tryPass("B", cur);
        if(resB.ok){ next.laneB = resB.lane; }
        else { bPassFailed = true; }
      }
      if(next.posA === next.posB && next.laneA === next.laneB){
        next.laneB = cur.laneB;
      }
    }

    // Movement phase (exact steps; destination occupancy only)
    const afterPass = {posA: next.posA, laneA: next.laneA, posB: next.posB, laneB: next.laneB};

    let aMove = null;
    let bMove = null;

    if(choiceA === "ACCELERATE"){
      aMove = moveAccelerate("A", afterPass);
      next.posA = aMove.pos;
    } else if(choiceA === "PASS" && aPassFailed){
      aMove = moveForwardFixed("A", afterPass, PASS_FAIL_FWD);
      next.posA = aMove.pos;
    } else {
      aMove = { intendedTarget: afterPass.posA, pos: afterPass.posA, adjusted:false, reason:null };
      next.posA = afterPass.posA;
    }

    if(choiceB === "ACCELERATE"){
      bMove = moveAccelerate("B", afterPass);
      next.posB = bMove.pos;
    } else if(choiceB === "PASS" && bPassFailed){
      bMove = moveForwardFixed("B", afterPass, PASS_FAIL_FWD);
      next.posB = bMove.pos;
    } else {
      bMove = { intendedTarget: afterPass.posB, pos: afterPass.posB, adjusted:false, reason:null };
      next.posB = afterPass.posB;
    }

    fuel = Math.max(0, fuel - 1);

    const aRollText = catchupA ? `${baseRollA}â†’${rollA}` : `r${rollA}`;
    const bRollText = catchupB ? `${baseRollB}â†’${rollB}` : `r${rollB}`;

    log(`A:${choiceA.padEnd(10)} ${aRollText.padEnd(6)} | B:${choiceB.padEnd(10)} ${bRollText}`);
    if(catchupA) log(`CATCH-UP: A roll doubled (${baseRollA}â†’${rollA})`);
    if(catchupB) log(`CATCH-UP: B roll doubled (${baseRollB}â†’${rollB})`);

    const aMoveKind = (choiceA === "ACCELERATE") ? "ACC" : (choiceA === "PASS" && aPassFailed) ? "PASSFAIL" : "PASS";
    const bMoveKind = (choiceB === "ACCELERATE") ? "ACC" : (choiceB === "PASS" && bPassFailed) ? "PASSFAIL" : "PASS";

    const aMoveRollText = (aMoveKind === "ACC") ? aRollText :
                          (aMoveKind === "PASSFAIL") ? `+${PASS_FAIL_FWD} (passfail)` : `0 (pass)`;
    const bMoveRollText = (bMoveKind === "ACC") ? bRollText :
                          (bMoveKind === "PASSFAIL") ? `+${PASS_FAIL_FWD} (passfail)` : `0 (pass)`;

    log(logMove("A", aMoveKind, aMoveRollText, start.posA, start.laneA, aMove.intendedTarget, next.posA, next.laneA, aMove.adjusted, aMove.reason));
    log(logMove("B", bMoveKind, bMoveRollText, start.posB, start.laneB, bMove.intendedTarget, next.posB, next.laneB, bMove.adjusted, bMove.reason));

    if(noteA){
      log(noteA);
      if(noteA.includes("FAIL")) doFlash(noteA, COLORS.B);
      if(noteA.includes("SUCCESS")) doFlash(noteA, COLORS.A);
    }

    posA = next.posA; laneA = next.laneA;
    posB = next.posB; laneB = next.laneB;

    syncUI();
    animateTo({posA, laneA, posB, laneB});
  }

  // ---------- rendering ----------
  function gridToScreen(pt, pad){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const innerW = w - pad*2;
    const innerH = h - pad*2;
    const sx = innerW / (GRID_W - 1);
    const sy = innerH / (GRID_H - 1);
    return { x: pad + pt.x * sx, y: pad + pt.y * sy };
  }

  function laneNormalAt(i){
    const a = track[Math.max(0, i-1)];
    const b = track[Math.min(track.length-1, i+1)];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    let nx = -dy, ny = dx;
    const len = Math.hypot(nx, ny) || 1;
    nx /= len; ny /= len;
    return {nx, ny};
  }

  function pointOnLane(posFloat, lane){
    const i0 = Math.floor(posFloat);
    const i1 = Math.min(TRACK_LEN, i0 + 1);
    const t = posFloat - i0;

    const p0 = track[i0], p1 = track[i1];
    const base = { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t };

    const {nx, ny} = laneNormalAt(i0);
    const sep = 0.35;
    const side = (lane === 0 ? -1 : 1);
    return { x: base.x + nx * sep * side, y: base.y + ny * sep * side };
  }

  function drawTrack(pad){
    const center = track.map(pt => gridToScreen(pt, pad));
    const rail0 = [], rail1 = [];
    for(let i=0;i<track.length;i++){
      const {nx, ny} = laneNormalAt(i);
      const sep = 0.35;
      const p = track[i];
      rail0.push(gridToScreen({x:p.x + nx*sep*-1, y:p.y + ny*sep*-1}, pad));
      rail1.push(gridToScreen({x:p.x + nx*sep* 1, y:p.y + ny*sep* 1}, pad));
    }

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.strokeStyle = COLORS.glow;
    ctx.lineWidth = 18;
    ctx.beginPath();
    ctx.moveTo(center[0].x, center[0].y);
    for(const p of center) ctx.lineTo(p.x, p.y);
    ctx.stroke();

    const stroke = (arr) => {
      ctx.strokeStyle = COLORS.rail;
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(arr[0].x, arr[0].y);
      for(const p of arr) ctx.lineTo(p.x, p.y);
      ctx.stroke();
    };
    stroke(rail0); stroke(rail1);

    const start = center[0];
    const finish = center[center.length-1];
    ctx.fillStyle = "rgba(233,238,247,.7)";
    ctx.font = "700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText("START", start.x + 10, start.y - 10);
    ctx.fillText("FINISH", finish.x + 10, finish.y - 10);

    ctx.strokeStyle = "rgba(233,238,247,.18)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(finish.x - 12, finish.y - 12);
    ctx.lineTo(finish.x + 12, finish.y + 12);
    ctx.stroke();
  }

  function drawRacer(label, color, posFloat, laneFloat){
    const p0 = pointOnLane(posFloat, 0);
    const p1 = pointOnLane(posFloat, 1);
    const t = clamp(laneFloat, 0, 1);
    const p = { x: p0.x + (p1.x - p0.x) * t, y: p0.y + (p1.y - p0.y) * t };
    const sp = gridToScreen(p, 34);

    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.beginPath();
    ctx.arc(sp.x+2, sp.y+2, 14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(sp.x, sp.y, 14, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "#0b0c10";
    ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, sp.x, sp.y + 0.5);
  }

  function drawHUD(){
    const w = canvas.getBoundingClientRect().width;

    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(14, 14, 310, 54);
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.strokeRect(14, 14, 310, 54);

    ctx.fillStyle = "rgba(233,238,247,.85)";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`FUEL ${fuel}/${FUEL_MAX}`, 26, 24);

    const diff = posA - posB;
    const diffText = diff === 0 ? "TIE" : (diff > 0 ? `A+${diff}` : `B+${Math.abs(diff)}`);
    ctx.font = "900 16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`A=${posA}  B=${posB}  (${diffText})`, 26, 40);

    if(flash){
      const t = (performance.now() - flash.t0) / flash.ms;
      if(t >= 1){ flash = null; return; }
      const alpha = (t < 0.15) ? (t/0.15) : (t > 0.85 ? (1-t)/0.15 : 1);

      ctx.fillStyle = `rgba(0,0,0,${0.40*alpha})`;
      ctx.fillRect(w/2 - 190, 18, 380, 44);
      ctx.strokeStyle = `rgba(255,255,255,${0.10*alpha})`;
      ctx.strokeRect(w/2 - 190, 18, 380, 44);

      ctx.fillStyle = flash.color;
      ctx.font = "900 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(flash.text, w/2, 40);
    }
  }

  function draw(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#0b0c10";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(255,255,255,.035)";
    ctx.lineWidth = 1;
    for(let x=0;x<w;x+=24){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=24){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    drawTrack(34);
    drawRacer("A", COLORS.A, anim.a.pos, anim.a.lane);
    drawRacer("B", COLORS.B, anim.b.pos, anim.b.lane);
    drawHUD();
  }

  // ---------- ROLL with catch-up ----------
  function applyCatchupDoubles(){
    catchupA = false;
    catchupB = false;

    if(posA === posB) return; // tie: no catch-up
    const trailing = (posA < posB) ? "A" : "B";
    if(rng() < CATCHUP_CHANCE){
      if(trailing === "A"){ catchupA = true; rollA = baseRollA * 2; }
      else { catchupB = true; rollB = baseRollB * 2; }
    }
  }

  // ---------- input ----------
  btnRoll.addEventListener('click', () => {
    if(phase !== "needRoll") return;

    baseRollA = randInt(rng, 1, 6);
    baseRollB = randInt(rng, 1, 6);

    rollA = baseRollA;
    rollB = baseRollB;

    applyCatchupDoubles();

    // Show the catch-up flash (subtle)
    if(catchupA) doFlash(`CATCH-UP: A ${baseRollA}â†’${rollA}`, COLORS.A);
    if(catchupB) doFlash(`CATCH-UP: B ${baseRollB}â†’${rollB}`, COLORS.B);

    phase = "needChoice";
    syncUI();
    draw();
  });

  function choose(action){
    if(phase !== "needChoice") return;
    choiceA = action;
    choiceB = cpuChoose();
    resolveTurn();
  }
  btnAccel.addEventListener('click', () => choose("ACCELERATE"));
  btnPass.addEventListener('click',  () => choose("PASS"));

  btnNew.addEventListener('click', () => newRace());
  btnSpeed.addEventListener('click', () => {
    speedMode = (speedMode === "normal") ? "fast" : "normal";
    syncUI();
  });

  // ---------- bootstrap ----------
  fitCanvas();
  newRace();
})();
</script>
</body>
</html>
